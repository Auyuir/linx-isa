// SPDX-License-Identifier: Apache-2.0
// SPDX-FileCopyrightText: 2026 Linx ISA contributors
//
// This file provides Block ISA interaction guidance for instruction groups.
// Include this after instruction_reference.adoc in the manual.

[[insnref-block-isa-guidance]]
=== Block ISA Interaction Guidelines

This section provides normative guidance on how each instruction group interacts with the Linx Block ISA.

[IMPORTANT]
====
All instructions MUST comply with the Block ISA safety rule: every architectural control-flow target MUST point at a block start marker. Branching to an address that does not begin with a block start marker MUST raise an exception. (Evidence: MAN-02)
====

==== Execution Control Instructions

Instructions: `ACRC`, `ACRE`, `ASSERT`, `BSE`, `BWE`, `BWI`, `BWT`, `EBREAK`, `FENCE.D`, `FENCE.I`

Block ISA interaction:

* `ACRC`: System-call request. MUST be the last instruction in its block. Triggers synchronous exception.
* `ACRE`: ACR enter request. MUST be the last instruction in its block. Triggers privilege transition at block commit.
* `ASSERT`: Assertion trap. Raises exception if `SrcL == 0`.
* `BSE`/`BWE`/`BWI`/`BWT`: Write-back enable/disable for tile/vector operations. Valid inside blocks.
* `EBREAK`: Breakpoint exception. Raises exception with `imm4` payload.
* `FENCE.D`: Data memory fence. Orders memory operations within the block.
* `FENCE.I`: Instruction fence. Invalidates instruction cache entries within the block.

==== Arithmetic Instructions (64-bit and 32-bit)

Instructions: `ADD`, `ADDI`, `AND`, `ANDI`, `OR`, `ORI`, `SUB`, `SUBI`, `XOR`, `XORI`, `SLL`, `SLLI`, `SRA`, `SRAI`, `SRL`, `SRLI`, and their `W` (word) variants, plus `HL.*` forms

Block ISA interaction:

* These are standard ALU operations and are valid anywhere inside a block.
* Results MAY be written to architectural destination registers (`->Rd`) or ClockHands queues (`->t`/`->u`).
* No control-flow semantics; do not affect block boundaries.

==== Load/Store Instructions

Instructions: `LDL`, `SDL`, `LDI`, `SDI`, `LBI`, `SBI`, `LWI`, `SWI`, `LHL`, `SHL`, `LDW`, `SDW`, and their `U` (unsigned) variants, plus `HL.*` PC-relative forms

Block ISA interaction:

* Standard memory operations are valid anywhere inside a block.
* Pre/post-index forms update base registers within the block; these updates are committed at block boundary.
* Misaligned accesses: behavior is implementation-defined; platforms SHOULD specify whether misaligned access traps or is handled transparently.

==== Branch Instructions

Instructions: `B.EQ`, `B.NE`, `B.GE`, `B.LT`, `B.GEU`, `B.LTU`, `B.Z`, `B.NZ`, `J`, `JR`

Block ISA interaction:

* These instructions use the two-step convention:
  1. `SETC.*` / `C.SETC.*` sets the block condition (inside the block)
  2. `BSTART.* COND, <target>` commits the conditional branch (block boundary)
* Branch targets MUST be block start markers (safety rule).
* `J` and `JR` are unconditional jumps; `JR` uses register-based target.

==== Block Marker Instructions

Instructions: `BSTART`, `C.BSTART`, `BSTOP`, `C.BSTOP`, `BSTART.*` variants, `HL.BSTART.*` variants

Block ISA interaction:

* These ARE block start markers or block terminators.
* `BSTART.*` / `C.BSTART.*`: Begin a new block; terminate the previous block.
* `BSTOP` / `C.BSTOP`: Explicitly terminate the current block.
* See <<blockisa>> for full block form definitions (coupled, decoupled, template).

==== Frame Template Instructions

Instructions: `FENTRY`, `FEXIT`, `FRET.RA`, `FRET.STK`

Block ISA interaction:

* Template blocks are STANDALONE blocks (Evidence: MAN-04).
* MUST NOT appear inside `BSTART..BSTOP` coupled blocks or inside decoupled bodies.
* Are valid architectural control-flow targets (safety rule applies).
* Encode register save/restore and stack adjustment in a single architectural operation.

==== Compare and Condition Instructions

Instructions: `CMP.EQ`, `CMP.NE`, `CMP.GE`, `CMP.LT`, `CMP.GEU`, `CMP.LTU`, `CMP.AND`, `CMP.OR`, `SETC.EQ`, `SETC.NE`, `SETC.LT`, `SETC.GE`, `SETC.LTU`, `SETC.GEU`, and their immediate variants

Block ISA interaction:

* `CMP.*`: Compare instructions that write results (used for predicated execution).
* `SETC.*`: Block condition setters. MUST execute inside a block (after a block start marker).
* `SETC.*` updates BARG state but does not itself transfer control.
* Call/return convention: `BSTART CALL` and `SETRET` MUST be adjacent with no instruction between them (Evidence: MAN-07).

==== Block Argument and Attribute Instructions

Instructions: `B.ARG`, `B.ATTR`, `B.DIM`, `B.HINT`, `B.IOD`, `B.IOR`, `B.IOT`, `B.IOTI`, `B.TEXT`

Block ISA interaction:

* These are block header descriptors and MUST appear only inside block headers (after `BSTART.*`).
* `B.TEXT`: Required in decoupled block headers to specify body entrypoint.
* `B.DIM`: Sets loop-bound registers (LB0, LB1, LB2) for tile/vector operations.
* `B.ATTR`: Sets block attributes (atomicity, ordering, data layout).
* `B.HINT`: Optimization hints for the execution engine.
* `B.IOD`/`B.IOR`/`B.IOT`/`B.IOTI`: Tile block input/output descriptors.

==== Floating-Point Instructions

Instructions: `FADD`, `FSUB`, `FMUL`, `FDIV`, `FSQRT`, `FMADD`, `FMSUB`, `FNMADD`, `FNMSUB`, `FCVT`, `FCVTA`, `FCVTM`, `FCVTN`, `FCVTP`, `FCVTZ`, `FABS`, `FMAX`, `FMIN`, `FEQ`, `FNE`, `FLT`, `FGE`, and their sized variants

Block ISA interaction:

* Standard floating-point operations are valid anywhere inside a block.
* No special Block ISA semantics; behave like ALU operations for control-flow purposes.
* Floating-point exceptions do not raise traps in v0.3; they update sticky status registers (e.g., `FFLAGS`).

==== Tile and Vector Instructions (v0.3)

Instructions: `BSTART.TMA`, `BSTART.CUBE`, `BSTART.VPAR`, `BSTART.VSEQ`, `BSTART.MPAR`, `BSTART.MSEQ`, `TLOAD`, `TSTORE`, `MAMULB`, `TCVT`, and related forms

Block ISA interaction:

* Tile/vector blocks use decoupled form with header + out-of-line body.
* Headers contain `BSTART.<type>` followed by `B.*` descriptors including `B.TEXT` for body pointer.
* Bodies MUST be linear (no branches, calls, returns, or block markers) and terminate at `BSTOP`.
* See <<blockisa-forms-decoupled>> for complete rules.

==== PC-Relative Instructions

Instructions: `ADDTPC`, `HL.ADDTPC`, `SETRET`, `HL.SETRET`

Block ISA interaction:

* `ADDTPC`: PC-relative add; writes result without control-flow transfer.
* `SETRET`: Return address materialization. MUST appear immediately after `BSTART CALL` (adjacency rule).
* PC-relative offsets are halfword-scaled: `target = TPC + (imm << 1)`.
